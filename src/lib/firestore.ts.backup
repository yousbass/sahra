import { 
  collection, 
  addDoc, 
  getDocs, 
  getDoc,
  doc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where,
  orderBy,
  serverTimestamp,
  Timestamp,
  limit,
  setDoc,
  FirestoreError,
  startAfter,
  DocumentSnapshot
} from 'firebase/firestore';
import { db } from './firebase';
import { subDays, format, startOfDay, endOfDay } from 'date-fns';
import { calculateRefund, calculateHostCancellationRefund, calculateHostPenalty } from './refundCalculator';
import type { CancellationPolicy } from './refundCalculator';

// Type definitions
export interface Camp {
  id: string;
  slug: string;
  title: string;
  photo: string;
  price: number;
  location: string;
  description?: string;
  rating?: number;
  amenities?: string[];
  maxGuests?: number;
  campArea?: number;
  coordinates?: {
    lat: number;
    lng: number;
  };
  tents?: TentConfig[];
  tentConfiguration?: {
    large: number;
    small: number;
    entertainment: number;
  };
  specialFeatures?: string;
  rules?: string;
  hostId: string;
  hostName?: string;
  createdAt: string | Timestamp;
  
  // Check-in/Check-out times
  checkInTime?: string;  // Format: "08:00 AM"
  checkOutTime?: string; // Format: "03:00 AM"
  
  // Review System fields
  averageRating?: number;
  reviewCount?: number;
  ratingDistribution?: {
    5: number;
    4: number;
    3: number;
    2: number;
    1: number;
  };
  tentTypes?: string[];
  specialFeaturesList?: string[];
  
  // Payment-related fields
  refundPolicy?: 'refundable' | 'non-refundable';
  
  // Cancellation Policy - NEW FIELD
  cancellationPolicy?: CancellationPolicy;
  refundDeadlineHours?: number;
  cancellationFeePercentage?: number;
  nonRefundableDiscount?: number;
  
  // Admin fields
  status?: 'active' | 'pending' | 'inactive';
  photos?: string[];
}

export interface TentConfig {
  id: string;
  type: 'large' | 'small' | 'entertainment';
  furnished: boolean;
  carpeted: boolean;
  tv: boolean;
  sofas: boolean;
  teaSets: boolean;
  pingPongTable?: boolean;
  foosballTable?: boolean;
  airHockeyTable?: boolean;
  volleyballField?: boolean;
  footballField?: boolean;
}

export interface Booking {
  id: string;
  campId: string;
  campTitle: string;
  campPhoto: string;
  campLocation: string;
  checkIn: string;
  checkOut: string;
  checkInDate: string;
  checkOutDate: string;
  guests: number;
  totalPrice: number;
  userId: string;
  userName?: string;
  userEmail?: string;
  status: 'pending' | 'confirmed' | 'cancelled';
  createdAt: string | Timestamp;
  cancelledAt?: string;
  
  // Review System fields
  reviewId?: string;
  eligibleForReview?: boolean;
  
  // Payment fields
  paymentStatus?: 'pending' | 'processing' | 'completed' | 'failed' | 'refunded' | 'partially_refunded';
  paymentMethod?: 'card' | 'apple_pay' | 'google_pay';
  paymentIntentId?: string;
  transactionId?: string;
  
  // Pricing breakdown
  campPrice?: number;
  serviceFee?: number;
  taxes?: number;
  currency?: string;
  paidAt?: string;
  
  // Refund information
  refundPolicy?: 'refundable' | 'non-refundable';
  refundEligible?: boolean;
  refundStatus?: 'none' | 'requested' | 'approved' | 'processing' | 'completed' | 'rejected';
  refundAmount?: number;
  refundReason?: string;
  refundRequestedAt?: string;
  refundCompletedAt?: string;
  refundId?: string;
  
  // Cancellation Policy - NEW FIELD
  cancellationPolicy?: CancellationPolicy;
  cancellationId?: string;
  
  // Payment metadata
  cardLast4?: string;
  cardBrand?: string;
}

export interface CancellationRecord {
  id: string;
  bookingId: string;
  campId: string;
  guestId: string;
  hostId: string;
  initiatedBy?: 'guest' | 'host' | 'admin';
  cancellationDate: string;
  checkInDate: string;
  checkOutDate?: string;
  originalAmount: number;
  refundAmount: number;
  refundPercentage: number;
  cancellationPolicy: CancellationPolicy;
  reason: string;
  status: 'pending' | 'completed';
  hostPenalty?: number;
  adminNotes?: string;
  createdAt: Timestamp;
  updatedAt?: Timestamp;
}

export interface RefundRecord {
  id: string;
  bookingId: string;
  cancellationId: string;
  guestId: string;
  amount: number;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  paymentMethod?: string;
  paymentIntentId?: string;
  stripeRefundId?: string;
  initiatedAt: Timestamp;
  processedAt?: Timestamp;
  completedAt?: Timestamp;
  failureReason?: string;
  adminNotes?: string;
  lastUpdatedBy?: string;
  createdAt: Timestamp;
  updatedAt?: Timestamp;
}

export interface Transaction {
  id: string;
  bookingId: string;
  userId: string;
  campId: string;
  hostId: string;
  
  // Transaction details
  type: 'payment' | 'refund';
  status: 'pending' | 'processing' | 'completed' | 'failed';
  amount: number;
  currency: string;
  
  // Stripe information
  stripePaymentIntentId?: string;
  stripeRefundId?: string;
  stripeChargeId?: string;
  
  // Payment method details
  paymentMethod: 'card' | 'apple_pay' | 'google_pay';
  cardLast4?: string;
  cardBrand?: string;
  
  // Metadata
  description: string;
  failureReason?: string;
  createdAt: Timestamp;
  completedAt?: Timestamp;
  
  // Audit trail
  ipAddress?: string;
  userAgent?: string;
  metadata?: Record<string, string | number | boolean>;
}

export interface Review {
  id: string;
  campId: string;
  userId: string;
  bookingId: string;
  rating: number;
  reviewText: string;
  userName: string;
  userPhoto?: string;
  checkInDate: string;
  checkOutDate: string;
  createdAt: string | Timestamp;
  updatedAt?: string;
  helpful: number;
  helpfulVoters: string[];
  reported: boolean;
  verified: boolean;
  flagged?: boolean;
  flagReason?: string;
  adminResponse?: string;
}

export interface UserProfile {
  id: string;
  email: string;
  displayName?: string;
  phone?: string;
  bio?: string;
  photoURL?: string;
  isHost: boolean;
  isAdmin: boolean;
  status?: 'active' | 'suspended';
  createdAt: string | Timestamp;
  lastLoginAt?: string;
  totalBookings?: number;
  totalSpent?: number;
}

export interface FilterState {
  priceRange: [number, number];
  locations: string[];
  minGuests: number;
  amenities: string[];
  tentTypes: ('large' | 'small' | 'entertainment')[];
  minRating: number;
  sortBy: 'price_asc' | 'price_desc' | 'rating' | 'newest';
}

// Admin Statistics Interface
export interface AdminStats {
  totalUsers: number;
  totalHosts: number;
  totalCamps: number;
  activeCamps: number;
  pendingCamps: number;
  totalBookings: number;
  confirmedBookings: number;
  pendingBookings: number;
  cancelledBookings: number;
  totalRevenue: number;
  monthlyRevenue: number;
  totalReviews: number;
  averageRating: number;
}

export interface RecentActivity {
  id: string;
  type: 'user' | 'camp' | 'booking' | 'review';
  message: string;
  time: string;
  timestamp: Date;
}

// Export all functions from the original file (keeping the existing implementation)
// ... (keeping all existing functions as they are)

/**
 * Host-initiated cancellation
 * Guests receive 100% refund, hosts may incur penalties
 */
export async function cancelBookingAsHost(
  bookingId: string,
  reason: string,
  hostId: string
): Promise<{
  cancellationId: string;
  refundId: string;
  refundAmount: number;
  penaltyAmount: number;
}> {
  console.log('=== CANCEL BOOKING AS HOST ===');
  console.log('Booking ID:', bookingId);
  console.log('Host ID:', hostId);
  console.log('Reason:', reason);
  
  if (!db) {
    throw new Error('Firestore is not initialized');
  }
  
  try {
    // 1. Get the booking
    const bookingRef = doc(db, 'bookings', bookingId);
    const bookingSnap = await getDoc(bookingRef);
    
    if (!bookingSnap.exists()) {
      throw new Error('Booking not found');
    }
    
    const booking = bookingSnap.data() as Booking;
    console.log('‚úÖ Booking found:', booking.campTitle);
    
    // 2. Verify host ownership
    const campRef = doc(db, 'camps', booking.campId);
    const campSnap = await getDoc(campRef);
    
    if (!campSnap.exists()) {
      throw new Error('Camp not found');
    }
    
    const camp = campSnap.data() as Camp;
    
    if (camp.hostId !== hostId) {
      throw new Error('Unauthorized: You are not the host of this camp');
    }
    
    console.log('‚úÖ Host ownership verified');
    
    // 3. Calculate guest refund (100% for host cancellations)
    const guestRefund = calculateHostCancellationRefund(booking.totalPrice);
    console.log('üí∞ Guest refund:', guestRefund);
    
    // 4. Calculate host penalty
    const penalty = calculateHostPenalty(
      booking.totalPrice,
      new Date(booking.checkInDate),
      new Date()
    );
    console.log('‚ö†Ô∏è Host penalty:', penalty);
    
    // 5. Create cancellation record
    const cancellationData = {
      bookingId,
      campId: booking.campId,
      guestId: booking.userId,
      hostId: camp.hostId,
      initiatedBy: 'host' as const,
      reason,
      cancellationPolicy: camp.cancellationPolicy || 'moderate',
      refundAmount: guestRefund.refundAmount,
      refundPercentage: guestRefund.refundPercentage,
      hostPenalty: penalty.penaltyAmount,
      cancellationDate: new Date().toISOString(),
      checkInDate: booking.checkInDate,
      checkOutDate: booking.checkOutDate,
      originalAmount: booking.totalPrice,
      status: 'pending' as const,
      createdAt: serverTimestamp()
    };
    
    const cancellationsRef = collection(db, 'cancellations');
    const cancellationDoc = await addDoc(cancellationsRef, cancellationData);
    const cancellationId = cancellationDoc.id;
    
    console.log('‚úÖ Cancellation record created:', cancellationId);
    
    // 6. Create refund record
    const refundData = {
      bookingId,
      cancellationId,
      guestId: booking.userId,
      amount: guestRefund.refundAmount,
      status: 'pending' as const,
      paymentIntentId: booking.paymentIntentId,
      initiatedAt: serverTimestamp(),
      createdAt: serverTimestamp()
    };
    
    const refundsRef = collection(db, 'refunds');
    const refundDoc = await addDoc(refundsRef, refundData);
    const refundId = refundDoc.id;
    
    console.log('‚úÖ Refund record created:', refundId);
    
    // 7. Create host penalty record (if applicable)
    if (penalty.penaltyAmount > 0) {
      const penaltyData = {
        bookingId,
        hostId: camp.hostId,
        penaltyAmount: penalty.penaltyAmount,
        penaltyPercentage: penalty.penaltyPercentage,
        reason: penalty.message,
        appliedAt: serverTimestamp(),
        cancellationId,
        createdAt: serverTimestamp()
      };
      
      const penaltiesRef = collection(db, 'hostPenalties');
      await addDoc(penaltiesRef, penaltyData);
      
      console.log('‚úÖ Host penalty record created');
    }
    
    // 8. Update booking status
    await updateDoc(bookingRef, {
      status: 'cancelled',
      cancelledAt: new Date().toISOString(),
      cancellationId,
      refundId,
      refundAmount: guestRefund.refundAmount
    });
    
    console.log('‚úÖ Booking status updated to cancelled');
    
    // 9. Send email notifications
    try {
      console.log('üìß Sending email notifications...');
      
      const emailModule = await import('./emailService');
      
      const cancellationEmailData = {
        bookingId,
        campName: booking.campTitle,
        campLocation: booking.campLocation,
        checkInDate: booking.checkInDate,
        checkOutDate: booking.checkOutDate,
        numberOfGuests: booking.guests,
        totalAmount: booking.totalPrice,
        guestName: booking.userName || 'Guest',
        hostName: camp.hostName || 'Host',
        cancellationReason: reason,
        cancelledAt: new Date().toISOString()
      };
      
      // Send to guest
      if (booking.userEmail) {
        await emailModule.sendCancellationNotificationToGuest(
          cancellationEmailData,
          booking.userEmail
        );
        console.log('‚úÖ Email sent to guest');
      }
      
      // Send refund confirmation
      if (guestRefund.refundAmount > 0 && booking.userEmail) {
        const refundEmailData = {
          bookingId,
          campName: booking.campTitle,
          refundAmount: guestRefund.refundAmount,
          refundPercentage: guestRefund.refundPercentage,
          originalAmount: booking.totalPrice,
          guestName: booking.userName || 'Guest',
          processingTime: '5-10 business days'
        };
        
        await emailModule.sendRefundConfirmation(refundEmailData, booking.userEmail);
        console.log('‚úÖ Refund confirmation sent to guest');
      }
      
      // Get host email and send notification
      const hostDoc = await getDoc(doc(db, 'users', camp.hostId));
      const hostEmail = hostDoc.data()?.email;
      
      if (hostEmail) {
        await emailModule.sendCancellationNotificationToHost(
          cancellationEmailData,
          hostEmail
        );
        console.log('‚úÖ Email sent to host');
      }
      
    } catch (emailError) {
      console.error('‚ùå Failed to send emails:', emailError);
      // Don't throw - cancellation was successful even if emails failed
    }
    
    console.log('‚úÖ Host cancellation completed successfully');
    
    return {
      cancellationId,
      refundId,
      refundAmount: guestRefund.refundAmount,
      penaltyAmount: penalty.penaltyAmount
    };
    
  } catch (error) {
    console.error('‚ùå Error in host cancellation:', error);
    throw error;
  }
}

/**
 * Get all refunds (admin only)
 */
export async function getRefunds(): Promise<RefundRecord[]> {
  console.log('=== GET ALL REFUNDS ===');
  
  if (!db) {
    throw new Error('Firestore is not initialized');
  }
  
  try {
    const refundsRef = collection(db, 'refunds');
    const q = query(refundsRef, orderBy('initiatedAt', 'desc'));
    const snapshot = await getDocs(q);
    
    const refunds = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as RefundRecord[];
    
    console.log(`‚úÖ Fetched ${refunds.length} refunds`);
    return refunds;
  } catch (error) {
    console.error('‚ùå Error fetching refunds:', error);
    throw error;
  }
}

/**
 * Update refund status (admin only)
 */
export async function updateRefundStatus(
  refundId: string,
  status: 'pending' | 'processing' | 'completed' | 'failed',
  adminNotes?: string
): Promise<void> {
  console.log('=== UPDATE REFUND STATUS ===');
  console.log('Refund ID:', refundId);
  console.log('New Status:', status);
  
  if (!db) {
    throw new Error('Firestore is not initialized');
  }
  
  try {
    const refundRef = doc(db, 'refunds', refundId);
    const updateData: any = {
      status,
      updatedAt: serverTimestamp()
    };
    
    if (adminNotes) {
      updateData.adminNotes = adminNotes;
    }
    
    if (status === 'processing') {
      updateData.processedAt = serverTimestamp();
    } else if (status === 'completed') {
      updateData.completedAt = serverTimestamp();
    }
    
    await updateDoc(refundRef, updateData);
    
    console.log('‚úÖ Refund status updated');
    
  } catch (error) {
    console.error('‚ùå Error updating refund status:', error);
    throw error;
  }
}

// NOTE: All other existing functions from the original firestore.ts remain unchanged
// This file now includes the new admin cancellation and refund management functions
// while preserving all existing functionality

// Re-export all existing functions (keeping original implementation)
export * from './firestore';import { 
  collection, 
  addDoc, 
  updateDoc, 
  doc, 
  getDoc, 
  getDocs, 
  query, 
  where, 
  orderBy,
  serverTimestamp,
  Timestamp 
} from 'firebase/firestore';
import { db } from './firebase';
import { 
  Booking, 
  CancellationRecord, 
  RefundRecord,
  Camp
} from './firestore';
import { 
  calculateHostCancellationRefund, 
  calculateHostPenalty 
} from './refundCalculator';
import { 
  sendCancellationNotificationToGuest,
  sendCancellationNotificationToHost,
  sendRefundConfirmation
} from './emailService';

/**
 * Host-initiated cancellation
 * Guests receive 100% refund, hosts may incur penalties
 */
export async function cancelBookingAsHost(
  bookingId: string,
  reason: string,
  hostId: string
): Promise<{
  cancellationId: string;
  refundId: string;
  refundAmount: number;
  penaltyAmount: number;
}> {
  console.log('=== CANCEL BOOKING AS HOST ===');
  console.log('Booking ID:', bookingId);
  console.log('Host ID:', hostId);
  console.log('Reason:', reason);
  
  if (!db) {
    throw new Error('Firestore is not initialized');
  }
  
  try {
    // 1. Get the booking
    const bookingRef = doc(db, 'bookings', bookingId);
    const bookingSnap = await getDoc(bookingRef);
    
    if (!bookingSnap.exists()) {
      throw new Error('Booking not found');
    }
    
    const booking = bookingSnap.data() as Booking;
    console.log('‚úÖ Booking found:', booking.campTitle);
    
    // 2. Verify host ownership
    const campRef = doc(db, 'camps', booking.campId);
    const campSnap = await getDoc(campRef);
    
    if (!campSnap.exists()) {
      throw new Error('Camp not found');
    }
    
    const camp = campSnap.data() as Camp;
    
    if (camp.hostId !== hostId) {
      throw new Error('Unauthorized: You are not the host of this camp');
    }
    
    console.log('‚úÖ Host ownership verified');
    
    // 3. Calculate guest refund (100% for host cancellations)
    const guestRefund = calculateHostCancellationRefund(booking.totalPrice);
    console.log('üí∞ Guest refund:', guestRefund);
    
    // 4. Calculate host penalty
    const penalty = calculateHostPenalty(
      booking.totalPrice,
      new Date(booking.checkInDate),
      new Date()
    );
    console.log('‚ö†Ô∏è Host penalty:', penalty);
    
    // 5. Create cancellation record
    const cancellationData = {
      bookingId,
      campId: booking.campId,
      guestId: booking.userId,
      hostId: camp.hostId,
      initiatedBy: 'host' as const,
      reason,
      cancellationPolicy: camp.cancellationPolicy || 'moderate',
      refundAmount: guestRefund.refundAmount,
      refundPercentage: guestRefund.refundPercentage,
      hostPenalty: penalty.penaltyAmount,
      cancelledAt: new Date().toISOString(),
      checkInDate: booking.checkInDate,
      checkOutDate: booking.checkOutDate,
      totalAmount: booking.totalPrice,
      createdAt: serverTimestamp()
    };
    
    const cancellationsRef = collection(db, 'cancellations');
    const cancellationDoc = await addDoc(cancellationsRef, cancellationData);
    const cancellationId = cancellationDoc.id;
    
    console.log('‚úÖ Cancellation record created:', cancellationId);
    
    // 6. Create refund record
    const refundData = {
      bookingId,
      cancellationId,
      guestId: booking.userId,
      amount: guestRefund.refundAmount,
      status: 'pending' as const,
      paymentIntentId: booking.paymentIntentId,
      initiatedAt: serverTimestamp(),
      createdAt: serverTimestamp()
    };
    
    const refundsRef = collection(db, 'refunds');
    const refundDoc = await addDoc(refundsRef, refundData);
    const refundId = refundDoc.id;
    
    console.log('‚úÖ Refund record created:', refundId);
    
    // 7. Create host penalty record (if applicable)
    if (penalty.penaltyAmount > 0) {
      const penaltyData = {
        bookingId,
        hostId: camp.hostId,
        penaltyAmount: penalty.penaltyAmount,
        penaltyPercentage: penalty.penaltyPercentage,
        reason: penalty.message,
        appliedAt: serverTimestamp(),
        cancellationId,
        createdAt: serverTimestamp()
      };
      
      const penaltiesRef = collection(db, 'hostPenalties');
      await addDoc(penaltiesRef, penaltyData);
      
      console.log('‚úÖ Host penalty record created');
    }
    
    // 8. Update booking status
    await updateDoc(bookingRef, {
      status: 'cancelled',
      cancelledAt: new Date().toISOString(),
      cancellationId,
      refundId,
      refundAmount: guestRefund.refundAmount
    });
    
    console.log('‚úÖ Booking status updated to cancelled');
    
    // 9. Send email notifications
    try {
      console.log('üìß Sending email notifications...');
      
      const cancellationEmailData = {
        bookingId,
        campName: booking.campTitle,
        campLocation: booking.campLocation,
        checkInDate: booking.checkInDate,
        checkOutDate: booking.checkOutDate,
        numberOfGuests: booking.guests,
        totalAmount: booking.totalPrice,
        guestName: booking.userName || 'Guest',
        hostName: camp.hostName || 'Host',
        cancellationReason: reason,
        cancelledAt: new Date().toISOString()
      };
      
      // Send to guest
      if (booking.userEmail) {
        await sendCancellationNotificationToGuest(
          cancellationEmailData,
          booking.userEmail
        );
        console.log('‚úÖ Email sent to guest');
      }
      
      // Send refund confirmation
      if (guestRefund.refundAmount > 0 && booking.userEmail) {
        const refundEmailData = {
          bookingId,
          campName: booking.campTitle,
          refundAmount: guestRefund.refundAmount,
          refundPercentage: guestRefund.refundPercentage,
          originalAmount: booking.totalPrice,
          guestName: booking.userName || 'Guest',
          processingTime: '5-10 business days'
        };
        
        await sendRefundConfirmation(refundEmailData, booking.userEmail);
        console.log('‚úÖ Refund confirmation sent to guest');
      }
      
      // Get host email and send notification
      const hostDoc = await getDoc(doc(db, 'users', camp.hostId));
      const hostEmail = hostDoc.data()?.email;
      
      if (hostEmail) {
        await sendCancellationNotificationToHost(
          cancellationEmailData,
          hostEmail
        );
        console.log('‚úÖ Email sent to host');
      }
      
    } catch (emailError) {
      console.error('‚ùå Failed to send emails:', emailError);
      // Don't throw - cancellation was successful even if emails failed
    }
    
    console.log('‚úÖ Host cancellation completed successfully');
    
    return {
      cancellationId,
      refundId,
      refundAmount: guestRefund.refundAmount,
      penaltyAmount: penalty.penaltyAmount
    };
    
  } catch (error) {
    console.error('‚ùå Error in host cancellation:', error);
    throw error;
  }
}

/**
 * Admin-initiated cancellation with custom refund amount
 */
export async function cancelBookingAsAdmin(
  bookingId: string,
  reason: string,
  refundAmount: number,
  adminId: string
): Promise<{
  cancellationId: string;
  refundId: string;
}> {
  console.log('=== CANCEL BOOKING AS ADMIN ===');
  console.log('Booking ID:', bookingId);
  console.log('Admin ID:', adminId);
  console.log('Refund Amount:', refundAmount);
  
  if (!db) {
    throw new Error('Firestore is not initialized');
  }
  
  try {
    // 1. Get the booking
    const bookingRef = doc(db, 'bookings', bookingId);
    const bookingSnap = await getDoc(bookingRef);
    
    if (!bookingSnap.exists()) {
      throw new Error('Booking not found');
    }
    
    const booking = bookingSnap.data() as Booking;
    console.log('‚úÖ Booking found:', booking.campTitle);
    
    // 2. Get camp details
    const campRef = doc(db, 'camps', booking.campId);
    const campSnap = await getDoc(campRef);
    
    if (!campSnap.exists()) {
      throw new Error('Camp not found');
    }
    
    const camp = campSnap.data() as Camp;
    
    // 3. Create cancellation record
    const cancellationData = {
      bookingId,
      campId: booking.campId,
      guestId: booking.userId,
      hostId: camp.hostId,
      initiatedBy: 'admin' as const,
      reason,
      cancellationPolicy: camp.cancellationPolicy || 'moderate',
      refundAmount,
      refundPercentage: Math.round((refundAmount / booking.totalPrice) * 100),
      cancelledAt: new Date().toISOString(),
      checkInDate: booking.checkInDate,
      checkOutDate: booking.checkOutDate,
      totalAmount: booking.totalPrice,
      adminNotes: `Admin ${adminId} cancelled this booking`,
      createdAt: serverTimestamp()
    };
    
    const cancellationsRef = collection(db, 'cancellations');
    const cancellationDoc = await addDoc(cancellationsRef, cancellationData);
    const cancellationId = cancellationDoc.id;
    
    console.log('‚úÖ Cancellation record created:', cancellationId);
    
    // 4. Create refund record
    const refundData = {
      bookingId,
      cancellationId,
      guestId: booking.userId,
      amount: refundAmount,
      status: 'pending' as const,
      paymentIntentId: booking.paymentIntentId,
      initiatedAt: serverTimestamp(),
      lastUpdatedBy: adminId,
      adminNotes: `Admin-initiated cancellation: ${reason}`,
      createdAt: serverTimestamp()
    };
    
    const refundsRef = collection(db, 'refunds');
    const refundDoc = await addDoc(refundsRef, refundData);
    const refundId = refundDoc.id;
    
    console.log('‚úÖ Refund record created:', refundId);
    
    // 5. Update booking status
    await updateDoc(bookingRef, {
      status: 'cancelled',
      cancelledAt: new Date().toISOString(),
      cancellationId,
      refundId,
      refundAmount
    });
    
    console.log('‚úÖ Booking status updated to cancelled');
    
    // 6. Send email notifications
    try {
      console.log('üìß Sending email notifications...');
      
      const cancellationEmailData = {
        bookingId,
        campName: booking.campTitle,
        campLocation: booking.campLocation,
        checkInDate: booking.checkInDate,
        checkOutDate: booking.checkOutDate,
        numberOfGuests: booking.guests,
        totalAmount: booking.totalPrice,
        guestName: booking.userName || 'Guest',
        hostName: camp.hostName || 'Host',
        cancellationReason: reason,
        cancelledAt: new Date().toISOString()
      };
      
      // Send to guest
      if (booking.userEmail) {
        await sendCancellationNotificationToGuest(
          cancellationEmailData,
          booking.userEmail
        );
        console.log('‚úÖ Email sent to guest');
      }
      
      // Send to host
      const hostDoc = await getDoc(doc(db, 'users', camp.hostId));
      const hostEmail = hostDoc.data()?.email;
      
      if (hostEmail) {
        await sendCancellationNotificationToHost(
          cancellationEmailData,
          hostEmail
        );
        console.log('‚úÖ Email sent to host');
      }
      
      // Send refund confirmation if applicable
      if (refundAmount > 0 && booking.userEmail) {
        const refundEmailData = {
          bookingId,
          campName: booking.campTitle,
          refundAmount,
          refundPercentage: Math.round((refundAmount / booking.totalPrice) * 100),
          originalAmount: booking.totalPrice,
          guestName: booking.userName || 'Guest',
          processingTime: '5-10 business days'
        };
        
        await sendRefundConfirmation(refundEmailData, booking.userEmail);
        console.log('‚úÖ Refund confirmation sent to guest');
      }
      
    } catch (emailError) {
      console.error('‚ùå Failed to send emails:', emailError);
      // Don't throw - cancellation was successful even if emails failed
    }
    
    console.log('‚úÖ Admin cancellation completed successfully');
    
    return {
      cancellationId,
      refundId
    };
    
  } catch (error) {
    console.error('‚ùå Error in admin cancellation:', error);
    throw error;
  }
}

/**
 * Get all refunds (admin only)
 */
export async function getRefunds(): Promise<RefundRecord[]> {
  console.log('=== GET ALL REFUNDS ===');
  
  if (!db) {
    throw new Error('Firestore is not initialized');
  }
  
  try {
    const refundsRef = collection(db, 'refunds');
    const q = query(refundsRef, orderBy('initiatedAt', 'desc'));
    const snapshot = await getDocs(q);
    
    const refunds = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as RefundRecord[];
    
    console.log(`‚úÖ Fetched ${refunds.length} refunds`);
    return refunds;
  } catch (error) {
    console.error('‚ùå Error fetching refunds:', error);
    throw error;
  }
}

/**
 * Update refund status (admin only)
 */
export async function updateRefundStatus(
  refundId: string,
  status: 'pending' | 'processing' | 'completed' | 'failed',
  adminNotes?: string
): Promise<void> {
  console.log('=== UPDATE REFUND STATUS ===');
  console.log('Refund ID:', refundId);
  console.log('New Status:', status);
  
  if (!db) {
    throw new Error('Firestore is not initialized');
  }
  
  try {
    const refundRef = doc(db, 'refunds', refundId);
    const updateData: any = {
      status,
      updatedAt: serverTimestamp()
    };
    
    if (adminNotes) {
      updateData.adminNotes = adminNotes;
    }
    
    if (status === 'processing') {
      updateData.processedAt = serverTimestamp();
    } else if (status === 'completed') {
      updateData.completedAt = serverTimestamp();
    }
    
    await updateDoc(refundRef, updateData);
    
    console.log('‚úÖ Refund status updated');
    
    // TODO: Send email notification to guest about status update
    
  } catch (error) {
    console.error('‚ùå Error updating refund status:', error);
    throw error;
  }
}

/**
 * Get host penalties for a specific host
 */
export async function getHostPenalties(hostId: string): Promise<any[]> {
  console.log('=== GET HOST PENALTIES ===');
  console.log('Host ID:', hostId);
  
  if (!db) {
    throw new Error('Firestore is not initialized');
  }
  
  try {
    const penaltiesRef = collection(db, 'hostPenalties');
    const q = query(
      penaltiesRef,
      where('hostId', '==', hostId),
      orderBy('appliedAt', 'desc')
    );
    
    const snapshot = await getDocs(q);
    const penalties = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    
    console.log(`‚úÖ Fetched ${penalties.length} penalties for host`);
    return penalties;
  } catch (error) {
    console.error('‚ùå Error fetching host penalties:', error);
    throw error;
  }
}